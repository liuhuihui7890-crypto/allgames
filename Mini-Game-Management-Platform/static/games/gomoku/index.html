<!DOCTYPE html>
<html>
<head>
    <title>Gomoku</title>
    <style>
        body { background: #dcb35c; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: sans-serif; }
        canvas { background: #eacb82; box-shadow: 5px 5px 15px rgba(0,0,0,0.3); cursor: crosshair; }
        #msg { margin-top: 10px; font-size: 20px; font-weight: bold; color: #333; }
        button { margin-top: 10px; padding: 8px 16px; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="board" width="450" height="450"></canvas>
    <div id="msg">Your Turn (Black)</div>
    <button onclick="resetGame()">New Game</button>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const size = 15;
        const cellSize = 30;
        let board = [];
        let gameOver = false;
        let score = 0; 

        const urlParams = new URLSearchParams(window.location.search);
        const userId = urlParams.get('uid');
        const gameKey = urlParams.get('gkey') || 'gomoku';

        window.addEventListener('message', async function(e) {
            if(e.data === 'submit_and_exit') {
                await submitScore();
                window.parent.postMessage('score_submitted', '*');
            }
        });

        function initBoard() {
            board = Array(size).fill().map(() => Array(size).fill(0));
            drawBoard();
            gameOver = false;
            document.getElementById('msg').innerText = "Your Turn (Black)";
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.strokeStyle = "#000";
            for(let i=0; i<size; i++) {
                ctx.moveTo(15 + i*cellSize, 15);
                ctx.lineTo(15 + i*cellSize, 435);
                ctx.moveTo(15, 15 + i*cellSize);
                ctx.lineTo(435, 15 + i*cellSize);
            }
            ctx.stroke();

            // Draw center point
            ctx.beginPath();
            ctx.arc(15+7*cellSize, 15+7*cellSize, 4, 0, Math.PI*2);
            ctx.fillStyle = '#000';
            ctx.fill();

            // Draw pieces
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(board[y][x] !== 0) {
                        ctx.beginPath();
                        ctx.arc(15+x*cellSize, 15+y*cellSize, 13, 0, Math.PI*2);
                        
                        // Gradient for 3D look
                        const grad = ctx.createRadialGradient(
                            15+x*cellSize-4, 15+y*cellSize-4, 2,
                            15+x*cellSize, 15+y*cellSize, 13
                        );
                        
                        if(board[y][x] === 1) { // Black
                            grad.addColorStop(0, '#666');
                            grad.addColorStop(1, '#000');
                        } else { // White
                            grad.addColorStop(0, '#fff');
                            grad.addColorStop(1, '#ddd');
                        }
                        
                        ctx.fillStyle = grad;
                        ctx.fill();
                    }
                }
            }
        }

        canvas.addEventListener('click', e => {
            if(gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);
            
            if(x>=0 && x<size && y>=0 && y<size && board[y][x] === 0) {
                board[y][x] = 1; // Player
                drawBoard();
                if(checkWin(x, y, 1)) {
                    document.getElementById('msg').innerText = "You Win!";
                    gameOver = true;
                    score += 100;
                    submitScore();
                    return;
                }
                
                document.getElementById('msg').innerText = "Thinking...";
                // AI Turn
                setTimeout(aiMove, 50);
            }
        });

        // --- AI Logic ---
        
        function aiMove() {
            if(gameOver) return;
            
            let bestScore = -Infinity;
            let move = {x: -1, y: -1};
            
            // Check center start if empty (classic opening)
            const center = 7;
            if(board[center][center] === 0) {
                board[center][center] = 2;
                drawBoard();
                document.getElementById('msg').innerText = "Your Turn";
                return;
            }

            // Iterate all empty spots
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(board[y][x] === 0) {
                        // Evaluate score for AI (2) attacking
                        const attackScore = evaluatePoint(x, y, 2);
                        // Evaluate score for Player (1) attacking (so AI can block)
                        const defendScore = evaluatePoint(x, y, 1);
                        
                        // Total score. Defense is slightly more prioritized to not lose.
                        // But if AI has a winning move, it should take it.
                        let currentScore = attackScore + defendScore * 0.9;
                        
                        // Boost winning move
                        if(attackScore >= 10000) currentScore += 100000;
                        // Boost blocking winning move
                        if(defendScore >= 10000) currentScore += 50000;

                        if(currentScore > bestScore) {
                            bestScore = currentScore;
                            move = {x, y};
                        } else if (currentScore === bestScore && Math.random() > 0.5) {
                            // Randomize equal moves
                            move = {x, y};
                        }
                    }
                }
            }
            
            if(move.x !== -1) {
                board[move.y][move.x] = 2;
                drawBoard();
                if(checkWin(move.x, move.y, 2)) {
                    document.getElementById('msg').innerText = "AI Wins!";
                    gameOver = true;
                } else {
                    document.getElementById('msg').innerText = "Your Turn";
                }
            }
        }

        // Check patterns for a specific player at x,y
        function evaluatePoint(x, y, player) {
            let score = 0;
            // Directions: Horizontal, Vertical, Diagonal \, Diagonal /
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            
            for(let d of dirs) {
                const info = getLineInfo(x, y, d[0], d[1], player);
                score += scorePattern(info.count, info.openEnds, info.space);
            }
            return score;
        }

        function getLineInfo(cx, cy, dx, dy, player) {
            let count = 1;
            let openEnds = 0;
            let space = false; // Is there space to make 5?

            // Check forward
            let i=1;
            while(true) {
                const nx = cx + dx*i, ny = cy + dy*i;
                if(nx<0||nx>=size||ny<0||ny>=size) break;
                if(board[ny][nx] === player) { count++; }
                else if(board[ny][nx] === 0) { openEnds++; break; }
                else break; // Blocked
                i++;
            }
            
            // Check backward
            let j=1;
            while(true) {
                const nx = cx - dx*j, ny = cy - dy*j;
                if(nx<0||nx>=size||ny<0||ny>=size) break;
                if(board[ny][nx] === player) { count++; }
                else if(board[ny][nx] === 0) { openEnds++; break; }
                else break; // Blocked
                j++;
            }
            return {count, openEnds};
        }

        function scorePattern(count, openEnds, space) {
            if (count >= 5) return 100000;
            if (count === 4) {
                if (openEnds === 2) return 10000; // Live 4 (Win next)
                if (openEnds === 1) return 1000;  // Dead 4 (Force block)
            }
            if (count === 3) {
                if (openEnds === 2) return 1000; // Live 3
                if (openEnds === 1) return 100;  // Dead 3
            }
            if (count === 2) {
                if (openEnds === 2) return 100;
                if (openEnds === 1) return 10;
            }
            return 1;
        }

        // --- End AI Logic ---

        function checkWin(cx, cy, player) {
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            for(let d of dirs) {
                let count = 1;
                for(let i=1; i<5; i++) {
                    const nx = cx + d[0]*i, ny = cy + d[1]*i;
                    if(nx>=0 && nx<size && ny>=0 && ny<size && board[ny][nx] === player) count++; else break;
                }
                for(let i=1; i<5; i++) {
                    const nx = cx - d[0]*i, ny = cy - d[1]*i;
                    if(nx>=0 && nx<size && ny>=0 && ny<size && board[ny][nx] === player) count++; else break;
                }
                if(count >= 5) return true;
            }
            return false;
        }

        async function submitScore() {
            if(!userId) return;
            try {
                await fetch('/api/scores', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ game_key: gameKey, user_id: parseInt(userId), score: score })
                });
            } catch(e) {}
        }
        
        function resetGame() {
            initBoard();
        }

        initBoard();
    </script>
</body>
</html>