<!DOCTYPE html>
<html>
<head>
    <title>Raiden</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; }
        canvas { border: 2px solid #333; background: #000510; box-shadow: 0 0 20px rgba(0,100,255,0.2); }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game State
    let score = 0;
    let gameOver = false;
    let frames = 0;
    
    // Player
    const player = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        w: 30, h: 30,
        speed: 5,
        dx: 0, dy: 0,
        bullets: []
    };

    // Enemies
    let enemies = [];
    const enemySpawnRate = 60; // frames

    // Controls
    const keys = {};

    const urlParams = new URLSearchParams(window.location.search);
    const userId = urlParams.get('uid');
    const gameKey = urlParams.get('gkey') || 'raiden';

    window.addEventListener('keydown', e => { keys[e.code] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // Exit Handler
    window.addEventListener('message', async function(e) {
        if(e.data === 'submit_and_exit') {
            await submitScore();
            window.parent.postMessage('score_submitted', '*');
        }
    });
    window.onload = () => window.focus();

    function update() {
        if (gameOver) return;
        frames++;

        // Player Move
        if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
        if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
        if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
        if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

        // Shoot
        if (keys['Space'] && frames % 10 === 0) {
            player.bullets.push({ x: player.x + player.w/2, y: player.y, r: 4, speed: 7 });
        }

        // Bullets
        player.bullets.forEach((b, i) => {
            b.y -= b.speed;
            if (b.y < 0) player.bullets.splice(i, 1);
        });

        // Spawn Enemies
        if (frames % enemySpawnRate === 0) {
            enemies.push({
                x: Math.random() * (canvas.width - 30),
                y: -30,
                w: 30, h: 30,
                speed: 2 + Math.random() * 2,
                hp: 1
            });
        }

        // Update Enemies & Collision
        enemies.forEach((e, i) => {
            e.y += e.speed;
            
            // Hit Player
            if (rectIntersect(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
                endGame();
            }

            // Off screen
            if (e.y > canvas.height) enemies.splice(i, 1);

            // Hit by bullet
            player.bullets.forEach((b, bi) => {
                if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                    enemies.splice(i, 1);
                    player.bullets.splice(bi, 1);
                    score += 10;
                }
            });
        });
    }

    function draw() {
        ctx.fillStyle = '#000510';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Starfield
        ctx.fillStyle = '#fff';
        for(let i=0; i<10; i++) ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 1, 1);

        // Player
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.moveTo(player.x + player.w/2, player.y);
        ctx.lineTo(player.x + player.w, player.y + player.h);
        ctx.lineTo(player.x + player.w/2, player.y + player.h - 10);
        ctx.lineTo(player.x, player.y + player.h);
        ctx.fill();

        // Bullets
        ctx.fillStyle = '#ff0';
        player.bullets.forEach(b => {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
            ctx.fill();
        });

        // Enemies
        ctx.fillStyle = '#f00';
        enemies.forEach(e => {
            ctx.beginPath();
            ctx.moveTo(e.x, e.y);
            ctx.lineTo(e.x + e.w, e.y);
            ctx.lineTo(e.x + e.w/2, e.y + e.h);
            ctx.fill();
        });

        // Score
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);

        if (gameOver) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '40px Arial';
            ctx.fillText('GAME OVER', 80, canvas.height/2);
            ctx.font = '20px Arial';
            ctx.fillText('Click to Restart', 130, canvas.height/2 + 40);
        }
    }

    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    async function endGame() {
        gameOver = true;
        await submitScore();
    }

    async function submitScore() {
        if(!userId) return;
        try {
            await fetch('/api/scores', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ game_key: gameKey, user_id: parseInt(userId), score: score })
            });
        } catch(e) {}
    }

    canvas.addEventListener('click', () => {
        if (gameOver) {
            score = 0; enemies = []; player.bullets = []; gameOver = false;
            player.x = canvas.width/2; player.y = canvas.height-50;
            loop();
        }
    });

    function loop() {
        if(!gameOver) requestAnimationFrame(loop);
        update();
        draw();
    }

    loop();
</script>
</body>
</html>