<!DOCTYPE html>
<html>
<head>
    <title>Raiden</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; }
        canvas { border: 2px solid #333; background: #000510; box-shadow: 0 0 20px rgba(0,100,255,0.2); }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game State
    let score = 0;
    let gameOver = false;
    let frames = 0;
    
    // Starfield for parallax background
    const stars = [];
    for(let i=0; i<50; i++) stars.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*2, speed: 0.5 + Math.random()});

    // Player
    const player = {
        x: canvas.width / 2,
        y: canvas.height - 80,
        w: 40, h: 40,
        speed: 5,
        bullets: []
    };

    // Enemies
    let enemies = [];
    let explosions = [];
    const enemySpawnRate = 60; // frames

    // Controls
    const keys = {};

    const urlParams = new URLSearchParams(window.location.search);
    const userId = urlParams.get('uid');
    const gameKey = urlParams.get('gkey') || 'raiden';

    window.addEventListener('keydown', e => { keys[e.code] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    window.addEventListener('message', async function(e) {
        if(e.data === 'submit_and_exit') {
            await submitScore();
            window.parent.postMessage('score_submitted', '*');
        }
    });
    window.onload = () => window.focus();

    function update() {
        if (gameOver) return;
        frames++;

        // Update Background
        stars.forEach(s => {
            s.y += s.speed;
            if(s.y > canvas.height) { s.y = 0; s.x = Math.random()*canvas.width; }
        });

        // Player Move
        if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
        if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
        if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
        if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

        // Shoot
        if (keys['Space'] && frames % 8 === 0) {
            player.bullets.push({ x: player.x + player.w/2 - 2, y: player.y, w: 4, h: 15, speed: 10 });
        }

        // Bullets
        for(let i=player.bullets.length-1; i>=0; i--) {
            let b = player.bullets[i];
            b.y -= b.speed;
            if (b.y < 0) player.bullets.splice(i, 1);
        }

        // Spawn Enemies
        if (frames % enemySpawnRate === 0) {
            const type = Math.random() > 0.8 ? 2 : 1; // 20% chance for bigger enemy
            enemies.push({
                x: Math.random() * (canvas.width - 40),
                y: -40,
                w: type===2 ? 50:30, h: type===2?50:30,
                speed: type===2 ? 1.5 : 3,
                hp: type===2 ? 5 : 1,
                type: type,
                angle: 0
            });
        }

        // Update Enemies & Collision
        for(let i=enemies.length-1; i>=0; i--) {
            let e = enemies[i];
            e.y += e.speed;
            e.angle += 0.05; // Rotate slightly
            
            // Hit Player
            if (rectIntersect(player.x+10, player.y+10, player.w-20, player.h-20, e.x, e.y, e.w, e.h)) {
                createExplosion(player.x, player.y, 'orange');
                endGame();
            }

            // Off screen
            if (e.y > canvas.height) { enemies.splice(i, 1); continue; }

            // Hit by bullet
            for(let j=player.bullets.length-1; j>=0; j--) {
                let b = player.bullets[j];
                if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                    player.bullets.splice(j, 1);
                    e.hp--;
                    createExplosion(b.x, b.y, 'cyan'); // Spark
                    if(e.hp <= 0) {
                        createExplosion(e.x + e.w/2, e.y + e.h/2, 'red');
                        enemies.splice(i, 1);
                        score += e.type * 100;
                        break;
                    }
                }
            }
        }

        // Update Explosions
        for(let i=explosions.length-1; i>=0; i--) {
            let ex = explosions[i];
            ex.r += 1;
            ex.life--;
            if(ex.life <= 0) explosions.splice(i, 1);
        }
    }

    function createExplosion(x, y, color) {
        // Simple particle explosion
        for(let i=0; i<8; i++) {
            explosions.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
                life: 20, color: color, r: 2
            });
        }
    }

    function draw() {
        ctx.fillStyle = '#000510';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Stars
        ctx.fillStyle = '#aaa';
        stars.forEach(s => {
            ctx.globalAlpha = Math.random() * 0.5 + 0.5;
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Draw Player (Advanced Shape)
        ctx.save();
        ctx.translate(player.x + player.w/2, player.y + player.h/2);
        
        // Thruster flame
        if(!gameOver) {
            ctx.fillStyle = 'orange';
            ctx.beginPath();
            ctx.moveTo(-5, 15); ctx.lineTo(0, 25 + Math.random()*10); ctx.lineTo(5, 15);
            ctx.fill();
        }

        // Ship Body
        ctx.fillStyle = '#3498db'; // Blue body
        ctx.beginPath();
        ctx.moveTo(0, -20); // Nose
        ctx.lineTo(15, 10); // Right Wing tip
        ctx.lineTo(5, 10);  // Right engine in
        ctx.lineTo(8, 20);  // Right engine out
        ctx.lineTo(-8, 20); // Left engine out
        ctx.lineTo(-5, 10); // Left engine in
        ctx.lineTo(-15, 10); // Left Wing tip
        ctx.closePath();
        ctx.fill();
        
        // Cockpit
        ctx.fillStyle = '#aed6f1';
        ctx.beginPath(); ctx.ellipse(0, -5, 3, 8, 0, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();

        // Draw Bullets (Laser style)
        ctx.fillStyle = '#0ff';
        ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
        player.bullets.forEach(b => {
            ctx.fillRect(b.x, b.y, b.w, b.h);
        });
        ctx.shadowBlur = 0;

        // Draw Enemies
        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x + e.w/2, e.y + e.h/2);
            // ctx.rotate(e.angle); // Optional rotation
            
            if(e.type === 1) {
                // Small Enemy: Triangle shape
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(0, 15); ctx.lineTo(15, -15); ctx.lineTo(-15, -15);
                ctx.fill();
            } else {
                // Big Enemy: Hexagon shape
                ctx.fillStyle = '#8e44ad';
                ctx.beginPath();
                for(let i=0; i<6; i++) {
                    ctx.lineTo(25 * Math.cos(i * Math.PI/3), 25 * Math.sin(i * Math.PI/3));
                }
                ctx.fill();
                // Core
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
            }
            ctx.restore();
        });

        // Draw Explosions
        explosions.forEach(ex => {
            ctx.fillStyle = ex.color;
            ctx.globalAlpha = ex.life / 20;
            ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.r, 0, Math.PI*2); ctx.fill();
            ex.x += ex.vx; ex.y += ex.vy;
        });
        ctx.globalAlpha = 1;

        // Score
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);

        if (gameOver) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MISSION FAILED', canvas.width/2, canvas.height/2);
            ctx.font = '20px Arial';
            ctx.fillText('Click to Retry', canvas.width/2, canvas.height/2 + 40);
            ctx.textAlign = 'left';
        }
    }

    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    async function endGame() {
        gameOver = true;
        await submitScore();
    }

    async function submitScore() {
        if(!userId) return;
        try {
            await fetch('/api/scores', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ game_key: gameKey, user_id: parseInt(userId), score: score })
            });
        } catch(e) {}
    }

    canvas.addEventListener('click', () => {
        if (gameOver) {
            score = 0; enemies = []; player.bullets = []; explosions=[]; gameOver = false;
            player.x = canvas.width/2; player.y = canvas.height-80;
            loop();
        }
    });

    function loop() {
        if(!gameOver) requestAnimationFrame(loop);
        update();
        draw();
    }

    loop();
</script>
</body>
</html>