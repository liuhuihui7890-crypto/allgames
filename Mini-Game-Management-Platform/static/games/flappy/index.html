<!DOCTYPE html>
<html>
<head>
    <title>Flappy</title>
    <style>
        body { margin: 0; background: #70c5ce; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif;}
        canvas { border: 2px solid #fff; background: #70c5ce; box-shadow: 0 0 20px rgba(0,0,0,0.2); }
    </style>
</head>
<body>
<canvas id="canvas" width="320" height="480"></canvas>
<script>
    const cvs = document.getElementById("canvas");
    const ctx = cvs.getContext("2d");

    let frames = 0;
    const DEGREE = Math.PI/180;

    const urlParams = new URLSearchParams(window.location.search);
    const userId = urlParams.get('uid');
    const gameKey = urlParams.get('gkey');

    const state = { current: 0, getReady: 0, game: 1, over: 2 };
    const startBtn = { x: 120, y: 263, w: 83, h: 29 };

    cvs.addEventListener("click", function(evt){
        switch(state.current){
            case state.getReady: state.current = state.game; break;
            case state.game: bird.flap(); break;
            case state.over:
                const rect = cvs.getBoundingClientRect();
                const clickX = evt.clientX - rect.left;
                const clickY = evt.clientY - rect.top;
                if(clickX >= startBtn.x && clickX <= startBtn.x + startBtn.w && clickY >= startBtn.y && clickY <= startBtn.y + startBtn.h){
                    bird.speedReset();
                    pipes.reset();
                    score.reset();
                    state.current = state.getReady;
                }
                break;
        }
    });

    const score = {
        best: 0,
        value: 0,
        draw: function(){
            ctx.fillStyle = "#FFF";
            ctx.strokeStyle = "#000";
            if(state.current == state.game){
                ctx.lineWidth = 2;
                ctx.font = "35px Teko";
                ctx.fillText(this.value, cvs.width/2, 50);
                ctx.strokeText(this.value, cvs.width/2, 50);
            }else if(state.current == state.over){
                ctx.font = "25px Teko";
                ctx.fillText(this.value, 225, 186);
                ctx.strokeText(this.value, 225, 186);
                ctx.fillText(this.best, 225, 228);
                ctx.strokeText(this.best, 225, 228);
            }
        },
        reset: function(){ this.value = 0; }
    }

    const bird = {
        x: 50, y: 150, radius: 12, speed: 0, gravity: 0.25, jump: 3.6,
        rotation: 0,
        
        draw: function(){
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // 根据速度计算旋转角度
            // 当向上飞时抬头，向下飞时低头
            if (this.speed < 0) this.rotation = -25 * DEGREE;
            else {
                this.rotation += 2 * DEGREE;
                if(this.rotation > 90 * DEGREE) this.rotation = 90 * DEGREE;
            }
            if(state.current == state.getReady) this.rotation = 0;

            ctx.rotate(this.rotation);

            // === 绘制小鸟 ===
            
            // 身体 (黄色)
            ctx.fillStyle = "#facc15"; // yellow-400
            ctx.beginPath();
            ctx.ellipse(0, 0, 17, 12, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#854d0e"; // brown
            ctx.stroke();

            // 眼睛 (白色底 + 黑色瞳孔)
            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(6, -6, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(8, -6, 1.5, 0, Math.PI*2);
            ctx.fill();

            // 翅膀 (白色)
            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.ellipse(-6, 2, 8, 5, -0.2, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();

            // 嘴巴 (橙色)
            ctx.fillStyle = "#f97316"; // orange-500
            ctx.beginPath();
            ctx.moveTo(8, 2);
            ctx.lineTo(16, 6);
            ctx.lineTo(8, 10);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        },
        flap: function(){ this.speed = -this.jump; },
        update: function(){
            if(state.current == state.getReady){ 
                this.y = 150; 
                this.rotation = 0;
            } else{
                this.speed += this.gravity;
                this.y += this.speed;
                if(this.y + this.radius >= cvs.height - 112){ 
                    this.y = cvs.height - 112 - this.radius;
                    if(state.current == state.game){
                        state.current = state.over;
                        submitScore(score.value);
                    }
                }
            }
        },
        speedReset: function(){ this.speed = 0; this.rotation = 0; }
    }

    const pipes = {
        position: [], w: 53, h: 400, gap: 100, dx: 2,
        draw: function(){
            for(let i=0; i<this.position.length; i++){
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.h + this.gap;
                
                // 管道主体
                ctx.fillStyle = "#74bf2e"; // 经典绿
                ctx.strokeStyle = "#558c22"; // 深绿描边
                ctx.lineWidth = 2;

                // 上管道
                ctx.fillRect(p.x, topY, this.w, this.h);
                ctx.strokeRect(p.x, topY, this.w, this.h);
                
                // 上管道口
                ctx.fillRect(p.x - 2, topY + this.h - 20, this.w + 4, 20);
                ctx.strokeRect(p.x - 2, topY + this.h - 20, this.w + 4, 20);

                // 下管道
                ctx.fillRect(p.x, bottomY, this.w, this.h);
                ctx.strokeRect(p.x, bottomY, this.w, this.h);

                // 下管道口
                ctx.fillRect(p.x - 2, bottomY, this.w + 4, 20);
                ctx.strokeRect(p.x - 2, bottomY, this.w + 4, 20);
            }
        },
        update: function(){
            if(state.current !== state.game) return;
            if(frames % 100 == 0){
                this.position.push({ x: cvs.width, y: -150 * (Math.random() + 1) });
            }
            for(let i=0; i<this.position.length; i++){
                let p = this.position[i];
                p.x -= this.dx;
                let bottomPipeY = p.y + this.h + this.gap;
                
                // Collision
                // 简单的矩形碰撞检测，为了配合新的小鸟形状，稍微宽容一点
                // bird box: x-12, y-12, w24, h24 approx
                if(bird.x + 8 > p.x && bird.x - 8 < p.x + this.w && 
                   (bird.y - 8 < p.y + this.h || bird.y + 8 > bottomPipeY)){
                    state.current = state.over;
                    submitScore(score.value);
                }
                if(p.x + this.w <= 0){
                    this.position.shift();
                    score.value += 1;
                    score.best = Math.max(score.value, score.best);
                }
            }
        },
        reset: function(){ this.position = []; }
    }

    function drawFg() {
        // 地面
        ctx.fillStyle = "#ded895";
        ctx.fillRect(0, cvs.height - 112, cvs.width, 112);
        
        // 地面顶部的草地线条
        ctx.fillStyle = "#73bf2e";
        ctx.fillRect(0, cvs.height - 112, cvs.width, 12);
        ctx.beginPath();
        ctx.moveTo(0, cvs.height - 112);
        ctx.lineTo(cvs.width, cvs.height - 112);
        ctx.stroke();
    }

    function draw() {
        ctx.fillStyle = "#70c5ce";
        ctx.fillRect(0,0,cvs.width, cvs.height);
        
        // 简单的云朵背景
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.beginPath();
        ctx.arc(50, 100, 20, 0, Math.PI*2);
        ctx.arc(80, 90, 25, 0, Math.PI*2);
        ctx.arc(110, 100, 20, 0, Math.PI*2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(200, 250, 30, 0, Math.PI*2);
        ctx.arc(240, 230, 40, 0, Math.PI*2);
        ctx.arc(280, 250, 30, 0, Math.PI*2);
        ctx.fill();

        pipes.draw();
        drawFg();
        bird.draw();
        score.draw();
        
        if(state.current == state.getReady) {
            ctx.fillStyle = "black"; ctx.font="30px Arial"; ctx.fillText("Click to Start", 70, 200);
            
            // 简单的操作提示图示
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.beginPath();
            ctx.arc(160, 280, 20, 0, Math.PI*2); // 手指点击位置
            ctx.stroke();
        }
        if(state.current == state.over) {
            ctx.fillStyle = "black"; ctx.font="40px Arial"; ctx.fillText("Game Over", 60, 150);
            
            // 重新开始按钮美化
            ctx.fillStyle = "#e53e3e"; // red-600
            ctx.beginPath();
            ctx.roundRect(startBtn.x, startBtn.y, startBtn.w, startBtn.h, 5);
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = "white"; 
            ctx.font="bold 18px Arial"; 
            ctx.fillText("RESTART", 125, 284);
        }
    }
    
    // 增加 roundRect polyfill 以防某些浏览器不支持
    if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.beginPath();
            this.moveTo(x+r, y);
            this.arcTo(x+w, y,   x+w, y+h, r);
            this.arcTo(x+w, y+h, x,   y+h, r);
            this.arcTo(x,   y+h, x,   y,   r);
            this.arcTo(x,   y,   x+w, y,   r);
            this.closePath();
            return this;
        };
    }

    function update() {
        bird.update();
        pipes.update();
    }
    function loop() {
        update();
        draw();
        frames++;
        requestAnimationFrame(loop);
    }

    async function submitScore(s) {
        if(!userId) return;
        try {
            await fetch('/api/scores', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    game_key: gameKey || 'flappy',
                    user_id: parseInt(userId),
                    score: s
                })
            });
        } catch(e) {}
    }
    loop();
</script>
</body>
</html>